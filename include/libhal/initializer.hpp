// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <array>
#include <concepts>
#include <cstdint>
#include <span>
#include <type_traits>

#include "error.hpp"
#include "units.hpp"

namespace hal {

template<std::uint64_t value>
struct selector_t
{
  static constexpr auto val = value;

  constexpr std::uint64_t operator()() const
  {
    return value;
  }
};

template<std::uint64_t value>
struct port_t : selector_t<value>
{};

template<std::uint64_t value>
struct pin_t : selector_t<value>
{};

template<std::uint64_t value>
struct bus_t : selector_t<value>
{};

template<std::uint64_t value>
struct channel_t : selector_t<value>
{};

template<std::uint64_t value>
struct buffer_t : selector_t<value>
{};

template<typename T>
concept port_param = std::is_same_v<port_t<T::val>, T>;
template<typename T>
concept pin_param = std::is_same_v<pin_t<T::val>, T>;
template<typename T>
concept bus_param = std::is_same_v<bus_t<T::val>, T>;
template<typename T>
concept channel_param = std::is_same_v<channel_t<T::val>, T>;
template<typename T>
concept buffer_param = std::is_same_v<buffer_t<T::val>, T>;

template<std::uint64_t value>
inline constexpr port_t<value> port{};
template<std::uint64_t value>
inline constexpr pin_t<value> pin{};
template<std::uint64_t value>
inline constexpr bus_t<value> bus{};
template<std::uint64_t value>
inline constexpr channel_t<value> channel{};
template<std::uint64_t value>
inline constexpr buffer_t<value> buffer{};

template<typename, typename = std::void_t<>>
struct has_singleton_trait : std::false_type
{};

template<typename T>
struct has_singleton_trait<T, std::void_t<decltype(T::singleton)>>
  : std::bool_constant<T::singleton>
{};

template<typename T>
inline constexpr bool has_singleton_trait_v = has_singleton_trait<T>::value;

/**
 * @brief
 *
 * @tparam storage_key_t
 * @tparam T
 * @tparam U
 */
template<class T, class storage_key_t, auto... U>
class entity
{
public:
  // A helper to let us check against the first template type in our concept.
  template<typename test_type>
  using match_entity_type = std::is_same<T, test_type>;

  entity(T* p_ref)
  {
    m_pointer = p_ref;
  }

  T* operator->() const noexcept
  {
    return m_pointer;
  };

  T* operator->() noexcept
  {
    return m_pointer;
  }

  T const& operator*() const noexcept
  {
    return *m_pointer;
  }

  T& operator*() noexcept
  {
    return *m_pointer;
  }

  T& ref() noexcept
  {
    return *m_pointer;
  }

  T* ptr() noexcept
  {
    return m_pointer;
  }

  operator T*() noexcept
  {
    return m_pointer;
  }

private:
  inline static T* m_pointer = nullptr;
};

template<typename T, typename entity_t>
concept entity_param =
  requires { typename T::template match_entity_type<entity_t>; };

template<typename storage_key, class U>
std::span<std::uint8_t> get_static_instance_memory()
{
  static std::array<std::uint8_t, sizeof(U)> instance_memory{};
  return instance_memory;
}

/**
 * @brief
 *
 * @tparam T
 * @tparam Args
 * @tparam decltype([] {})
 * @param args
 * @return result<entity<storage_key, T>>
 */
template<class T, typename storage_key = decltype([] {}), typename... Args>
result<entity<T, storage_key>> initialize(Args... args)
{
  // Create a status variable to check if the constructor was successful with
  // setup
  hal::status constructor_status = hal::success();

  std::span<std::uint8_t> instance_memory{};

  if constexpr (has_singleton_trait_v<T>) {
    // This type is a singleton, meaning that each call to initialize must refer
    // to the same exact object. In order to ensure that
    // `get_static_instance_memory()` returns the same statically allocated
    // buffer, make the storage_key and the type of the object. This removes the
    // uniqueness generated by `typename storage_key = decltype([] {})` by
    // ignoring it all together.
    instance_memory = get_static_instance_memory<T, T>();
  } else {
    // Acquire a statically allocated buffer equal to the size of the type T.
    // Uses the storage_key type to generate a unique type
    instance_memory = get_static_instance_memory<storage_key, T>();
  }

  // In place construct the object at the instance memory location.
  //
  // NOTE: that no dynamic memory is NOT being used here. The statically
  // allocated memory is being used in place of heap. No calls to malloc are
  // made.
  new (instance_memory.data()) T(constructor_status, args...);

  // Check if the constructor had an error and if so, relay it up.
  if (!constructor_status) {
    return constructor_status.error();
  }

  // Return a pointer to the instance memory to hal::entity so it can store
  // the pointer in a statically allocated memory address.
  return reinterpret_cast<T*>(instance_memory.data());
}

/**
 * @brief
 *
 * @tparam T
 * @tparam storage_key
 * @tparam Args
 * @param p_entity
 * @param args
 * @return hal::status
 */
template<class T, typename storage_key, typename... Args>
hal::status reinitialize(entity<T, storage_key> p_entity, Args... args)
{
  // Execute destructor if it exists
  if constexpr (std::is_destructible_v<T>) {
    p_entity.ref().~T();
  }

  hal::status constructor_status = hal::success();
  new (p_entity.ptr()) T(constructor_status, args...);
  return constructor_status;
}
}  // namespace hal

/**
 * @brief
 *
 */
#define HAL_ENABLE_INITIALIZER                                                 \
  template<class T, typename storage_key, typename... Args>                    \
  friend hal::result<hal::entity<T, storage_key>> hal::initialize(             \
    Args... args)

/**
 * @brief
 *
 */
#define HAL_ENABLE_REINITIALIZER                                               \
  template<class T, typename storage_key, typename... Args>                    \
  friend hal::status hal::reinitialize(hal::entity<T, storage_key> p_entity,   \
                                       Args... args)
